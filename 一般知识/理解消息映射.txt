理解消息映射
消息映射结构只能用于MFC。掌握它和如何在你的代码中应用它是很重要的。
可能纯C++使用者会对消息映射产生疑问: 为什么Microsoft不用虚拟函数来替代消息映射？虚拟函数是MFC中处理消息映射的标准C++方式，所以使用宏DECLARE_MESSAGE_MAP和BEGIN_MESSAGE_MAP可能有些怪异。
MFC使用消息映射来解决虚拟函数的基本问题。参见MFC帮助文件中的CWnd类。它包含200多个成员函数，所有的成员函数当不使用消息映射时都是虚拟的。现在来看一下所有CWnd类的子类。MFC中大约有近30个类是以CWnd为基类的。这包括所有的可见控制如按钮、静态标签和列表。现在想象一下，MFC使用虚拟函数，并且你建立一应用程序包含有20个控制。CWnd中的200个虚拟函数中的每个都需要自己的虚拟函数表，并且一个控制的每个例程都应有一组200个虚拟函数与之关联。则程序可能就有近4,000个虚拟函数表在内存中，这对内存有限的机器来说是个大问题。因为其中的大部分是不用的。
消息映射复制了虚拟函数表的操作，但是它是基于需要的基础之上的。当你在消息映射中建立一个入口时，你是在对系统说，“当你看见一个特殊的消息时，请调用指定的函数”。只有这些函数实际上被重载到消息映射中，着就节省了内存和CPU的负担。
当你用DECLARE_MESSAGE_MAP和BEGIN_MESSAGE_MAP说明消息映射时，系统会通过你的消息映射选择所有的消息。如果消息映射处理了给定的消息，则你的函数会被调用，卸车也就停留在此。但是，如果你的消息映射中不包含某个消息的入口，则系统会把该消息发送第二个BEGIN_MESSAGE_MAP指定的类。那个类可能会也可能不会处理它，如此重复。最后，如果没有消息映射处理一给定的消息，该消息会到由一缺省的处理函数来处理。
